#include <iostream>
#include <stdio.h>
#include <string>
#include <dirent.h>
#include <sys/stat.h>
#include <strings.h>
#include <stdlib.h>
#include "resource.h"
#include "LuxandFaceSDK.h"
#include <vector>
#include <string.h>
#include <thread>

#define SEGMENTATION_SIZE 5

using namespace std;
//각폴더안디렉토리
typedef std::vector<std::string>FILE_LIST;
class CFileList
{
public:
    CFileList();
    ~CFileList();
public:
    bool GetFileList(FILE_LIST& list, std::string strDir); //디렉토리 및 파일목록을 구한다
};

CFileList::CFileList()
{
}
CFileList::~CFileList()
{
}

bool CFileList::GetFileList(FILE_LIST& list, std::string strDir)
{

    struct stat st;
    memset(&st, 0, sizeof(st));
    lstat(strDir.c_str(), &st);
    if(!S_ISDIR(st.st_mode))
    {
        std::cout<<strDir + " is not directory"<<std::endl;
        return false;
    }
    DIR *dir;
    struct dirent *ent;
    if ((dir = opendir(strDir.c_str())) == NULL)
    {
        std::cout<<strDir + " open error"<<std::endl;
        return false;
    }
    while ((ent = readdir(dir)) != NULL)
    {
        memset(&st, 0, sizeof(st));
        std::string strFilePath = strDir + "/" + ent->d_name;
        while(strFilePath.find("//") != std::string::npos)
            strFilePath.replace(strFilePath.find("//"), 2, "/");
        lstat(strFilePath.c_str(), &st);
        if(S_ISDIR(st.st_mode)) // 디렉토리 이면
        {
            if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
                continue;
// list.insert(pair<string, bool>(strFilePath, true)); //디렉토리 경로를 넣음
            std::string strSubDir = strDir + "/" + ent->d_name;
            GetFileList(list, strSubDir); //디렉토리 안으로 들어감
        }
        else
        {
//파일이면
            list.push_back(strFilePath); //파일경로를 넣음
        }
    }
//읽은 디렉토리 닫기
    closedir(dir);
    return true;
}

//THREAD
void compareFunc(int key)
{
    int i=0;
    while(true) {
        cout <<key<<"thread:"<< i++ << "\n";
        if(i>10)
            break;
    }
}

void compareFunction(FILE_LIST s_file_list,FILE_LIST folder_list)
{
    
}

int main(int argc, char *argv[])
{
//라이센스
    if (FSDKE_OK != FSDK_ActivateLibrary(
            "HMGN4CkTERu0sktE6QbCrt/MS68qKuT5LQy35r6RbMNh1eBowWlj+RY9fHbg2jsuvH06uQdo4SkRDFHn0sU7KAzb0EevK/+l8qClcJZZIMUf2dP+FYwxlXdYFLr13oR95GwU5GHv+pPC0tVkOBbM0FMxO4Hn6gHnM3v5+gAOkDQ="))
    {
//MessageBox(0, L"Please run the License Key Wizard (Start - Luxand - FaceSDK - License Key Wizard)\n",
// L"Error activating FaceSDK", MB_ICONERROR | MB_OK);
        printf("Please run the License Key Wizard (Start - Luxand - FaceSDK - License Key Wizard)\\n");
        printf("Error activating FaceSDK");
        exit(-1);
    }
    FSDK_Initialize("");
    FSDK_InitializeCapturing();

    int cameraHandle = 0;

//각 폴더안 디렉토리
    CFileList FileList;

    FILE_LIST file_list;
    FILE_LIST file_list2;
    FILE_LIST temp_list;
    FileList.GetFileList(file_list, "/home/son/Desktop/wow/"); //비교할이미지
    FileList.GetFileList(file_list2, "/home/son/Desktop/img/"); //이미지저장

    FILE_LIST::iterator itr;
    FILE_LIST::iterator itr2;

    cout<<"filelist size:"<<file_list.size()<<"\n";
    int listSize=file_list.size();
    static int totalSize=listSize;
    vector<thread> t_vector;

    int i=0;
    while(listSize>0)
    {
        temp_list.clear();
        if(listSize-SEGMENTATION_SIZE>0) {
            for (int j = i; j < i + SEGMENTATION_SIZE; ++j) {
                temp_list.push_back(file_list[j]);
                listSize = listSize - 1;
            }
            i=i+SEGMENTATION_SIZE;
            //
        }
        else
        {
            for(int j=i;j<totalSize;++j)
            {
                temp_list.push_back(file_list[j]);
                listSize=listSize-1;
            }
            //thread(temp_list);
        }
    }

//같은이름 파일 비교
    for (itr = file_list.begin(); itr != file_list.end(); itr++)
    {
        HImage imageHandle;
        std::string s1 = strchr(itr->c_str() + 18, '/');
//파일명.png
        char temp[100];
        char *filename;
        strcpy(temp, s1.c_str());
        char *tok = strtok(temp, "/");
// tok= 파일명.png
        filename = strtok(tok, ".");
// filename=파일명
        for (itr2 = file_list2.begin(); itr2 != file_list2.end(); itr2++)
        {
            HImage imageHandle2;
            std::string s2 = strchr(itr2->c_str() + 18, '/');
//s2= /폴더명/파일명.png
            char temp2[100];
            char *foldername;
            strcpy(temp2, s2.c_str());
            char *tok = strtok(temp2, "/");
//tok = 폴더명/파일명.png
            foldername = tok;
//foldername=폴더명

            if (strcmp(filename, foldername) == 0)
            {
                printf("filename:");
                printf("%s\n",filename);
                printf("folder:");
                printf("%s\n",foldername);

//image similarity
                FSDK_LoadImageFromFile(&imageHandle, itr->c_str());
                FSDK_LoadImageFromFile(&imageHandle2, itr2->c_str());

                FSDK_FaceTemplate template1, template2;
                float MatchingThreshold, Similarity;
                FSDK_GetMatchingThresholdAtFAR(0.02, &MatchingThreshold);
                FSDK_GetFaceTemplate(imageHandle, &template1);
                FSDK_GetFaceTemplate(imageHandle2, &template2);
                FSDK_MatchFaces(&template1, &template2, &Similarity);

                if (Similarity > MatchingThreshold)
                {
                    printf("%.3f \n", Similarity);
                }
            }
        }
    }
    return 0;

}
